"""
Script Executor for handling script execution and process management.
"""

import os
import subprocess
import logging
from typing import Optional


class ScriptExecutor:
    """
    Handles script execution, environment setup, and process management.
    """
    
    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
    
    def execute_script(self, script_path: str, working_dir: str) -> int:
        """
        Execute a script in the specified working directory.
        
        Args:
            script_path: Path to script to execute
            working_dir: Working directory for execution
            
        Returns:
            Exit code of the script execution
        """
        self.logger.info(f"Executing script: {script_path}")
        self.logger.info(f"Working directory: {working_dir}")
        
        # Change to working directory
        original_dir = os.getcwd()
        os.chdir(working_dir)
        
        try:
            # Execute the script with real-time output streaming
            process = subprocess.Popen(
                ['python3', script_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                cwd=working_dir,
                bufsize=1,
                universal_newlines=True
            )
            
            # Stream output in real-time
            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    # Print the output directly to maintain the original logging format
                    print(output.strip())
            
            return_code = process.poll()
            
            if return_code == 0:
                self.logger.info("Script executed successfully")
            else:
                self.logger.error(f"Script execution failed with return code: {return_code}")
            
            return return_code
            
        except Exception as e:
            self.logger.error(f"Failed to execute script: {e}")
            return 1
        finally:
            # Restore original directory
            os.chdir(original_dir)
    
    def execute_linuxaioperf(self, working_dir: str) -> int:
        """
        Execute the linuxaioperf.py script.
        
        Args:
            working_dir: Working directory for execution
            
        Returns:
            Exit code of the script execution
        """
        script_path = os.path.join(working_dir, 'linuxaioperf.py')
        return self.execute_script(script_path, working_dir)
    
    def check_script_exists(self, script_path: str) -> bool:
        """
        Check if a script file exists.
        
        Args:
            script_path: Path to script file
            
        Returns:
            True if script exists, False otherwise
        """
        exists = os.path.exists(script_path)
        if not exists:
            self.logger.warning(f"Script not found: {script_path}")
        return exists
    
    def get_script_output_files(self, working_dir: str) -> list:
        """
        Get list of output files generated by script execution.
        
        Args:
            working_dir: Working directory to check for output files
            
        Returns:
            List of output file paths
        """
        output_files = []
        expected_files = [
            'linuxaioperf_report.html',
            '*.png',  # Plot files
            '*.csv'   # Data files
        ]
        
        for pattern in expected_files:
            import glob
            files = glob.glob(os.path.join(working_dir, pattern))
            output_files.extend(files)
        
        self.logger.info(f"Found {len(output_files)} output files")
        return output_files
